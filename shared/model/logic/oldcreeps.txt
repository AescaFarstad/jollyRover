#include <Creeps.h>
namespace Creeps
{
	using namespace CreepsInternal;
	
	void processCreeps(GameState* state, Prototypes* prototypes, int timePassed)
	{
		for(auto &force : prototypes->forces)
		{
			if (force.id == 3)
				continue;
			int32_t strength = 0;
			for(Creep& creep : state->creeps)
			{
				strength += prototypes->getCreep(creep.object.prototypeId)->cost;
			}
			
			if (state->random.get() > 0.9)
			{
				//spawnCreep(force.id, state, prototypes);
			}
		}
		/*if (state->creeps.size() == 0)
		{
			spawnCreep(1, state, prototypes);
			spawnCreep(2, state, prototypes);
			spawnCreep(1, state, prototypes);
			spawnCreep(2, state, prototypes);
			
		}*/
		
		for(auto &creep : state->creeps)
		{
			//if out of bounds -> go in bounds by shortest trajectory
			//else
				//ensureTarget
				//if no target -> do nothing
				//else if in range -> shoot
				//else move closer
			
			creep.weapon.attackCooldown -= timePassed;
			
			auto nearestEnemy = std::min_element(state->creeps.begin(), state->creeps.end(), [&creep](Creep& c1, Creep& c2){
				if (c1.unit.force == c2.unit.force)
					return creep.unit.location.distanceTo(c1.unit.location) < creep.unit.location.distanceTo(c2.unit.location);
				else
					return c1.unit.force != creep.unit.force;
			});
			if (nearestEnemy->unit.force != creep.unit.force)
			{
				auto distance = creep.unit.location.distanceTo(nearestEnemy->unit.location);
				const WeaponProto* weaponProto = prototypes->getWeapon(creep.weapon.prototypeId);
				const CreepProto* creepProto = prototypes->getCreep(creep.object.prototypeId);
				if (distance > weaponProto->range)
				{
					Point direction = nearestEnemy->unit.location.subtract(creep.unit.location);
					direction.scaleTo(creepProto->speed * timePassed / 1000.0);
					creep.unit.location.add(direction, creep.unit.location);
				}
				else
				{
					if (creep.weapon.attackCooldown <= 0)
					{
						creep.weapon.attackCooldown = 1000000 / weaponProto->attackSpeed;
						fireProjectile(creep.unit.location, nearestEnemy->unit.location, weaponProto, state);
						if (creep.object.prototypeId == 3)
						{
							creep.unit.health -= 1;
							if (creep.unit.health <= 0 || state->random.get() > 0.99)
							{
								fireProjectile(creep.unit.location, creep.unit.location, prototypes->getWeapon(5), state);
							}
						}
					}
				}
				
			}
		}
	}
	
	void processProjectiles(GameState* state, Prototypes* prototypes, int timePassed)
	{
		for(auto &proj : state->projectiles)
		{
			auto direction = proj.location.subtract(proj.target);
			float step = timePassed * proj.speed / 1000.0;
			
			if (direction.getLength() > step)
			{
				direction.scaleTo(-step);
				proj.location.add(direction, proj.location);
			}
			else
			{
				for(Creep& creep : state->creeps)
				{
					if (creep.unit.location.distanceTo(proj.target) < proj.splash)
					{
						creep.unit.health -= proj.damage;
					}
				}
				proj.damage = -1;
			}			
		}
	}
	
	void removeDeadProjectiles(GameState* state)
	{
		state->projectiles.erase(std::remove_if(state->projectiles.begin(), state->projectiles.end(), 
		[](Projectile& proj){
			return proj.damage == -1;
			}
		), state->projectiles.end());
	}
	
	void removeDeadCreeps(GameState* state)
	{
		state->creeps.erase(std::remove_if(state->creeps.begin(), state->creeps.end(), 
		[](Creep& creep){
			return creep.unit.health <= 0;
			}
		), state->creeps.end());
	}
	
	namespace CreepsInternal
	{
		
		void spawnCreep(int16_t force, GameState* state, Prototypes* prototypes)
		{
			//S::log.add("spawn creep");
			CreepProto& creepProto = state->random.getFromVector(prototypes->creeps);
			const WeaponProto* weaponProto = prototypes->getWeapon(creepProto.weapon);
			const ForceProto* forceProto = prototypes->getForce(force);
			
			
			state->creeps.emplace_back();
			Creep& creep = state->creeps.back();
			
			creep.object.prototypeId = creepProto.id;
			creep.object.id = state->idCounter++;
			
			creep.unit.force = force;
			creep.unit.health = creepProto.maxHealth;
			creep.unit.location.x = state->random.get(forceProto->spawnAA.x, forceProto->spawnBB.x);
			creep.unit.location.y = state->random.get(forceProto->spawnAA.y, forceProto->spawnBB.y);
			
			creep.weapon.prototypeId = weaponProto->id;
			creep.weapon.attackCooldown = 0;
			
		}
		
		void fireProjectile(Point& from, Point& to, const WeaponProto* prototype, GameState* state)
		{
			state->projectiles.emplace_back();
			Projectile& projectile = state->projectiles.back();
			
			auto distance = from.distanceTo(to);
			
			projectile.object.id = state->idCounter++;
			projectile.object.prototypeId = prototype->id;
			projectile.speed = prototype->bulletSpeed;
			projectile.splash = prototype->splash;
			projectile.damage = prototype->damage;
			projectile.target = to;
			projectile.location = from;
			
			projectile.target.x += state->random.get(-1.0f, 1.0f) * distance * 0.1;
			projectile.target.y += state->random.get(-1.0f, 1.0f) * distance * 0.1;
		}
	}
}